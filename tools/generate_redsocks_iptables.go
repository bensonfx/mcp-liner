package tools

import (
	"encoding/json"
	"fmt"
	"strings"

	"github.com/bensonfx/mcp-liner/internal/responses"
	"github.com/phuslu/log"
)

// GenerateRedsocksIptablesParams generate_redsocks_iptables工具的参数
type GenerateRedsocksIptablesParams struct {
	RedsocksPort int      `json:"redsocks_port"` // Redsocks监听端口
	LANInterface string   `json:"lan_interface"` // LAN接口名称，如 "mlan0"
	WANInterface string   `json:"wan_interface"` // WAN接口名称，如 "enp1s0"
	ProxyPorts   []int    `json:"proxy_ports"`   // 需要代理的端口，如 [80, 443]
	ExcludeCIDRs []string `json:"exclude_cidrs"` // 排除的CIDR，防止路由循环
	Format       string   `json:"format"`        // 输出格式: iptables-save|shell-script
}

// GenerateRedsocksIptables 生成Redsocks iptables规则
func GenerateRedsocksIptables(arguments json.RawMessage) (string, error) {
	var params GenerateRedsocksIptablesParams
	if err := json.Unmarshal(arguments, &params); err != nil {
		log.Error().Err(err).Msg("failed to parse parameters")
		return responses.ErrorResponse(
			fmt.Sprintf("Invalid parameters: %v", err),
			"Please provide valid parameters for iptables rules generation",
		)
	}

	log.Info().
		Int("redsocks_port", params.RedsocksPort).
		Str("lan_interface", params.LANInterface).
		Str("wan_interface", params.WANInterface).
		Str("format", params.Format).
		Msg("generating redsocks iptables rules")

	// 设置默认值
	if params.RedsocksPort == 0 {
		params.RedsocksPort = 12345
	}
	if params.LANInterface == "" {
		params.LANInterface = "eth0"
	}
	if params.WANInterface == "" {
		params.WANInterface = "eth1"
	}
	if len(params.ProxyPorts) == 0 {
		params.ProxyPorts = []int{80, 443}
	}
	if params.Format == "" {
		params.Format = "iptables-save"
	}

	// 默认排除私有网络和特殊地址，防止路由循环
	defaultExcludes := []string{
		"0.0.0.0/8",      // 当前网络
		"10.0.0.0/8",     // 私有网络A
		"127.0.0.0/8",    // 本地回环
		"169.254.0.0/16", // 链路本地
		"172.16.0.0/12",  // 私有网络B
		"192.168.0.0/16", // 私有网络C
		"224.0.0.0/4",    // 组播
		"240.0.0.0/4",    // 保留
	}

	// 合并用户提供的排除列表
	excludeCIDRs := make(map[string]bool)
	for _, cidr := range defaultExcludes {
		excludeCIDRs[cidr] = true
	}
	for _, cidr := range params.ExcludeCIDRs {
		if cidr != "" {
			excludeCIDRs[cidr] = true
		}
	}

	var content string

	switch params.Format {
	case "iptables-save":
		content = generateIptablesSaveFormat(params, excludeCIDRs)
	case "shell-script":
		content = generateShellScriptFormat(params, excludeCIDRs)
	default:
		return responses.ErrorResponse(
			fmt.Sprintf("Unknown format: %s", params.Format),
			"Supported formats: iptables-save, shell-script",
		)
	}

	description := fmt.Sprintf("Generated iptables rules for Redsocks transparent proxy (%s format)\n\n", params.Format)
	description += "⚠️  IMPORTANT WARNINGS:\n"
	description += "1. These rules will redirect ALL TCP traffic from LAN to redsocks\n"
	description += "2. Apply rules carefully - incorrect rules can break network connectivity\n"
	description += "3. Test in a safe environment first\n"
	description += "4. Make sure redsocks is running before applying rules\n\n"

	if params.Format == "iptables-save" {
		description += "To apply these rules:\n"
		description += "1. Save output to a file (e.g., redsocks.rules)\n"
		description += "2. Test: sudo iptables-restore --test < redsocks.rules\n"
		description += "3. Apply: sudo iptables-restore < redsocks.rules\n"
		description += "4. Make persistent (Ubuntu/Debian): sudo apt install iptables-persistent\n"
		description += "5. Save: sudo netfilter-persistent save\n"
	} else {
		description += "To apply these rules:\n"
		description += "1. Save output to a file (e.g., setup-redsocks.sh)\n"
		description += "2. Make executable: chmod +x setup-redsocks.sh\n"
		description += "3. Run as root: sudo ./setup-redsocks.sh\n"
	}

	log.Info().Msg("redsocks iptables rules generated successfully")
	return responses.SuccessResponse(content, description)
}

func generateIptablesSaveFormat(params GenerateRedsocksIptablesParams, excludeCIDRs map[string]bool) string {
	var b strings.Builder

	b.WriteString("# Generated iptables rules for Redsocks transparent proxy\n")
	b.WriteString("# Generated by mcp-liner\n")
	b.WriteString(fmt.Sprintf("# Redsocks port: %d\n", params.RedsocksPort))
	b.WriteString(fmt.Sprintf("# LAN interface: %s\n", params.LANInterface))
	b.WriteString(fmt.Sprintf("# WAN interface: %s\n", params.WANInterface))
	b.WriteString("\n")

	// NAT表
	b.WriteString("*nat\n")
	b.WriteString(":PREROUTING ACCEPT [0:0]\n")
	b.WriteString(":INPUT ACCEPT [0:0]\n")
	b.WriteString(":OUTPUT ACCEPT [0:0]\n")
	b.WriteString(":POSTROUTING ACCEPT [0:0]\n")
	b.WriteString(":REDSOCKS - [0:0]\n")
	b.WriteString("\n")

	// PREROUTING: 将LAN流量导向REDSOCKS链
	if len(params.ProxyPorts) > 0 {
		for _, port := range params.ProxyPorts {
			b.WriteString(fmt.Sprintf("-A PREROUTING -i %s -p tcp --dport %d -j REDSOCKS\n",
				params.LANInterface, port))
		}
	} else {
		b.WriteString(fmt.Sprintf("-A PREROUTING -i %s -p tcp -j REDSOCKS\n", params.LANInterface))
	}
	b.WriteString("\n")

	// POSTROUTING: 出站流量MASQUERADE
	b.WriteString(fmt.Sprintf("-A POSTROUTING -o %s -j MASQUERADE\n", params.WANInterface))
	b.WriteString("\n")

	// REDSOCKS链: 排除私有地址，然后重定向到redsocks端口
	b.WriteString("# REDSOCKS chain: exclude private addresses to prevent routing loops\n")
	for cidr := range excludeCIDRs {
		b.WriteString(fmt.Sprintf("-A REDSOCKS -d %s -j RETURN\n", cidr))
	}
	b.WriteString("\n")
	b.WriteString("# Redirect to redsocks port\n")
	b.WriteString(fmt.Sprintf("-A REDSOCKS -p tcp -j REDIRECT --to-ports %d\n", params.RedsocksPort))
	b.WriteString("\n")
	b.WriteString("COMMIT\n")
	b.WriteString("\n")

	// FILTER表 (可选的转发规则)
	b.WriteString("*filter\n")
	b.WriteString(":INPUT ACCEPT [0:0]\n")
	b.WriteString(":FORWARD ACCEPT [0:0]\n")
	b.WriteString(":OUTPUT ACCEPT [0:0]\n")
	b.WriteString("\n")
	b.WriteString("# Allow forwarding from LAN to WAN\n")
	b.WriteString(fmt.Sprintf("-A FORWARD -i %s -o %s -m state --state NEW,RELATED,ESTABLISHED -j ACCEPT\n",
		params.LANInterface, params.WANInterface))
	b.WriteString(fmt.Sprintf("-A FORWARD -i %s -o %s -m state --state RELATED,ESTABLISHED -j ACCEPT\n",
		params.WANInterface, params.LANInterface))
	b.WriteString("\n")
	b.WriteString("COMMIT\n")

	return b.String()
}

func generateShellScriptFormat(params GenerateRedsocksIptablesParams, excludeCIDRs map[string]bool) string {
	var b strings.Builder

	b.WriteString("#!/bin/bash\n")
	b.WriteString("# Generated iptables rules script for Redsocks transparent proxy\n")
	b.WriteString("# Generated by mcp-liner\n")
	b.WriteString(fmt.Sprintf("# Redsocks port: %d\n", params.RedsocksPort))
	b.WriteString(fmt.Sprintf("# LAN interface: %s\n", params.LANInterface))
	b.WriteString(fmt.Sprintf("# WAN interface: %s\n", params.WANInterface))
	b.WriteString("\n")
	b.WriteString("set -e\n")
	b.WriteString("\n")
	b.WriteString("echo \"Setting up iptables rules for Redsocks...\"\n")
	b.WriteString("\n")

	// 创建REDSOCKS链
	b.WriteString("# Create REDSOCKS chain\n")
	b.WriteString("iptables -t nat -N REDSOCKS 2>/dev/null || iptables -t nat -F REDSOCKS\n")
	b.WriteString("\n")

	// 排除私有地址
	b.WriteString("# Exclude private addresses to prevent routing loops\n")
	for cidr := range excludeCIDRs {
		b.WriteString(fmt.Sprintf("iptables -t nat -A REDSOCKS -d %s -j RETURN\n", cidr))
	}
	b.WriteString("\n")

	// 重定向到redsocks
	b.WriteString("# Redirect to redsocks port\n")
	b.WriteString(fmt.Sprintf("iptables -t nat -A REDSOCKS -p tcp -j REDIRECT --to-ports %d\n", params.RedsocksPort))
	b.WriteString("\n")

	// PREROUTING规则
	b.WriteString("# Add PREROUTING rules\n")
	if len(params.ProxyPorts) > 0 {
		for _, port := range params.ProxyPorts {
			b.WriteString(fmt.Sprintf("iptables -t nat -A PREROUTING -i %s -p tcp --dport %d -j REDSOCKS\n",
				params.LANInterface, port))
		}
	} else {
		b.WriteString(fmt.Sprintf("iptables -t nat -A PREROUTING -i %s -p tcp -j REDSOCKS\n", params.LANInterface))
	}
	b.WriteString("\n")

	// POSTROUTING MASQUERADE
	b.WriteString("# Enable MASQUERADE for outbound traffic\n")
	b.WriteString(fmt.Sprintf("iptables -t nat -A POSTROUTING -o %s -j MASQUERADE\n", params.WANInterface))
	b.WriteString("\n")

	// FORWARD规则
	b.WriteString("# Allow forwarding\n")
	b.WriteString(fmt.Sprintf("iptables -A FORWARD -i %s -o %s -m state --state NEW,RELATED,ESTABLISHED -j ACCEPT\n",
		params.LANInterface, params.WANInterface))
	b.WriteString(fmt.Sprintf("iptables -A FORWARD -i %s -o %s -m state --state RELATED,ESTABLISHED -j ACCEPT\n",
		params.WANInterface, params.LANInterface))
	b.WriteString("\n")

	b.WriteString("echo \"Redsocks iptables rules applied successfully!\"\n")
	b.WriteString("echo \"Current NAT rules:\"\n")
	b.WriteString("iptables -t nat -L -n -v\n")

	return b.String()
}
